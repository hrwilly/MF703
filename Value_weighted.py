import pandas as pdimport numpy as npimport statsmodels.api as sm############################# Load datareturns_df = pd.read_csv('monthly_return.csv')  returns_df['Date'] = pd.to_datetime(returns_df['Date'], format='%Y%m%d')ff4_factors = pd.read_csv('North_America_FF4.csv')  ff4_factors['Date'] = pd.to_datetime(ff4_factors['Date'], format='%Y%m')ff6_factors = pd.read_csv('North_America_FF6.csv')  ff6_factors['Date'] = pd.to_datetime(ff6_factors['Date'], format='%Y%m')market_cap_df = pd.read_csv('market_cap.csv')  market_cap_df['Date'] = pd.to_datetime(market_cap_df['Date'], format='%Y%m%d')ab_nr_df = pd.read_csv('abnormal_negative_ratio.csv') ab_nr_df['Date'] = pd.to_datetime(ab_nr_df['Date'], format='%Y-%m-%d')# Ensure all df are indexed by Datereturns_df.set_index('Date', inplace=True)ab_nr_df.set_index('Date', inplace=True)market_cap_df.set_index('Date', inplace=True)ff4_factors.set_index('Date', inplace=True)ff6_factors.set_index('Date', inplace=True)############################# value-weighted portfolio# Shift the AB_NR values forward by one month ab_nr_df_shifted = ab_nr_df.shift(1)# Rank stocks into deciles based on AB_NRdecile_ranks = ab_nr_df.apply(lambda x: pd.qcut(x, 10, labels=False, duplicates='drop'), axis=1)# Initialize df to hold the decile stock returnsdecile_returns = pd.DataFrame(index=returns_df.index, columns=np.arange(10))# Calculate value-weighted portfolio returns for each decilefor decile in range(10):    decile_stocks = decile_ranks == decile    decile_returns[decile] = (returns_df[decile_stocks] * market_cap_df[decile_stocks]).sum(axis=1) / market_cap_df[decile_stocks].sum(axis=1)# farma french regression model buildingdef perform_regression(decile_returns, ff_factors):    # Prepare the regression data    regression_data = pd.concat([decile_returns, ff_factors], axis=1).dropna()    Y = regression_data.iloc[:, 0]  # First column be portfolio returns    X = regression_data.iloc[:, 1:]  # Other columns are the factors    X = sm.add_constant(X)  # Adds a constant term to the predictor    model = sm.OLS(Y, X).fit()    return model.summary()# Function to extract alpha(excess return) and its t-stat def extract_alpha_tstat(summary):    # Assuming 'summary' is the result from the 'model.summary()'    alpha = summary.params[0]      t_stat = summary.tvalues[0]      return alpha, t_stat# Initialize result df results_table = pd.DataFrame(columns=['Decile', 'Raw Return', 'FF4 Alpha', 'FF4 t-stat', 'FF6 Alpha', 'FF6 t-stat'])# Store decile resultsfor decile in range(10):    decile_data = decile_returns.iloc[:, decile].dropna()        # Run FF4 regression    ff4_model = perform_regression(decile_data, ff4_factors)    ff4_alpha, ff4_tstat = extract_alpha_tstat(ff4_model)        # Run FF6 regression    ff6_model = perform_regression(decile_data, ff6_factors)    ff6_alpha, ff6_tstat = extract_alpha_tstat(ff6_model)    # Calculate raw return for the decile    raw_return = decile_data.mean()    # Add results to the table    results_table = results_table.append({        'Decile': decile + 1,        'Raw Return': raw_return,        'FF4 Alpha': ff4_alpha,        'FF4 t-stat': ff4_tstat,        'FF6 Alpha': ff6_alpha,        'FF6 t-stat': ff6_tstat    }, ignore_index=True)# Calculate the high minus low returnsresults_table['H-L'] = results_table.iloc[-1]['Raw Return'] - results_table.iloc[0]['Raw Return']print(results_table)results_table.to_csv('value_weighted_portfolio_returns.csv')############################# addressing firm size influence (drop top1%)# Identify the top 1% stocks by market cap top_1_percent_thresholds = market_cap_df.quantile(0.99, axis=1)# Excluding top 1%is_top_1_percent = market_cap_df.apply(lambda x: x >= top_1_percent_thresholds[x.name], axis=0)filtered_market_caps = market_cap_df[~is_top_1_percent]filtered_returns = returns_df[~is_top_1_percent]# Decile ranks without the top 1% filtered_decile_ranks = filtered_returns.apply(lambda x: pd.qcut(x.dropna(), 10, labels=False, duplicates='drop'), axis=1)# Initialize DataFrame to hold filtered decile returnsfiltered_decile_returns = pd.DataFrame(index=filtered_returns.index, columns=np.arange(10))# Calculate value-weighted returns for each filtered decilefor decile in range(10):    decile_stocks = filtered_decile_ranks == decile    weighted_returns = filtered_returns[decile_stocks].mul(filtered_market_caps[decile_stocks])    sum_weights = filtered_market_caps[decile_stocks].sum()    filtered_decile_returns[decile] = weighted_returns.sum(axis=1).div(sum_weights)# Perform the Fama-French regressions filtered_results_table = pd.DataFrame(columns=['Decile', 'Raw Return', 'FF4 Alpha', 'FF4 t-stat', 'FF6 Alpha', 'FF6 t-stat'])for decile in range(10):    # Get the returns for the current decile    decile_data = filtered_decile_returns[decile].dropna()        # Run the Fama-French regressions    ff4_result = perform_regression(decile_data, ff4_factors)    ff6_result = perform_regression(decile_data, ff6_factors)        # Extract the alpha and t-stats    ff4_alpha, ff4_tstat = extract_alpha_tstat(ff4_result)    ff6_alpha, ff6_tstat = extract_alpha_tstat(ff6_result)        # Calculate the raw return for the decile    raw_return = decile_data.mean()        # Add the results to the filtered results table    filtered_results_table.loc[decile] = {        'Decile': decile + 1,        'Raw Return': raw_return,        'FF4 Alpha': ff4_alpha,        'FF4 t-stat': ff4_tstat,        'FF6 Alpha': ff6_alpha,        'FF6 t-stat': ff6_tstat    }# Calculate H-L and compile resultfiltered_results_table['H-L'] = filtered_results_table['Raw Return'].iloc[-1] - filtered_results_table['Raw Return'].iloc[0]filtered_results_table.set_index('Decile', inplace=True)print(filtered_results_table)filtered_results_table.to_csv('filtered_value_weighted_portfolio_returns.csv')############################# hedged portfolio# Initialize DataFrame to hold hedge portfolio returnshedge_portfolio_returns = pd.DataFrame(index=returns_df.index, columns=np.arange(1, 11))# Calculate hedge portfolio returns for each size decilefor size_decile in range(1, 11):    # Get the stocks in the highest and lowest AB_NR quintiles within the size decile    high_ab_nr_stocks = ab_nr_quintile_ranks[size_decile] == 5    low_ab_nr_stocks = ab_nr_quintile_ranks[size_decile] == 1        # Calculate value-weighted returns for the high and low AB_NR quintiles    high_returns = (returns_df[high_ab_nr_stocks] * market_cap_df[high_ab_nr_stocks]).sum(axis=1) / market_cap_df[high_ab_nr_stocks].sum(axis=1)    low_returns = (returns_df[low_ab_nr_stocks] * market_cap_df[low_ab_nr_stocks]).sum(axis=1) / market_cap_df[low_ab_nr_stocks].sum(axis=1)        # Hedge portfolio return is the difference between high and low quintile returns    hedge_portfolio_returns[size_decile] = high_returns - low_returns# run regressionhedge_ff4_results = perform_regression(hedge_portfolio_returns, ff4_factors)hedge_ff6_results = perform_regression(hedge_portfolio_returns, ff6_factors)# Extract alpha and t-statistics and store them in a similar format as the tablehedge_results_table = pd.DataFrame()  # Create a DataFrame similar to the one in the screenshot# ... Add the regression results to 'hedge_results_table'# Print or save the hedge results tableprint(hedge_results_table)hedge_results_table.to_csv('hedge_portfolio_results.csv')